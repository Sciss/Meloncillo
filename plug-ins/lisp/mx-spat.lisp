; MAX/MSP PLUG-IN FOR USE WITH THE IRCAM SPAT~ EXTERNALS;; java object ids used: scosc	= datagram channel;						sctraj	= bytebuffer for trajectory data;						scsync	= datagram listening channel(println "MSP Spat~ Control v0.74 (23-May-05)"); iterate from startidx incl. to stopidx excl. using variable itervar and executing cmd; if success is NIL, iteration is aborted(defun iter (itervar startidx stopidx success cmd)	(if (and (eval success) (< startidx stopidx))		(progn			(set itervar startidx)			(eval cmd)			(iter itervar (1+ startidx) stopidx success cmd)		)	)); iterate from startidx incl. to stopidx excl. using variable itervar and executing cmd; if success evaluates to NIL, iteration is aborted(defun cycle (itervar alist success cmd)	(if (and (eval success) (not (null alist)))		(progn			(set itervar (car alist))			(eval cmd)			(cycle itervar (cdr alist) success cmd)		)	)); utility method for osc message block alignment(defun align (val block) (* (floor (/ (+ val (1- block)) block)) block))(defun concat-args (args)	(if (null args) "" (concatenate 'STRING (car args) " " (concat-args (cdr args))))); allocate next free buffer(defun alloc-buf NIL	(let ((result buf-counter))		(setq buf-counter (1+ buf-counter))		result	)); wrapper for (source-request) that; automatically handles realtime/bounce mode; and trns/rcv index lookup for given objects(defun request-traj (obj bufidx)	(let ((trnsidx (- (length colltrns) (length (member obj colltrns)))))		(if realtime			(source-request "TRAJ" trnsidx 'trajmsg (list				(list "INT" bufidx traj-msgbuf-off)				(list "VAR" "BUFOFF" (+ traj-msgbuf-off 4))				(list "STREAM" (+ traj-msgbuf-off 12))				(list "SEND" 'scosc)			))		; else			(let ((temp-file-name (temp-file-make))				  (temp-file-id (concatenate 'STRING "traj" bufidx)))				  				(audio-file-open temp-file-id temp-file-name "ircam" "float32" sense-rate)				(source-request "TRAJ" trnsidx temp-file-id)				(setq stream-files (append stream-files (list temp-file-name)))				(setq stream-bufidx (append stream-bufidx (list bufidx)))				(setq stream-fileids (append stream-fileids (list temp-file-id)))			)		)	)); looks up a session object in; a collection, using its name.; returns NIL if not found(defun find-by-name (coll name) (progn	(setq found-obj NIL)	(setq name-to-find name)	; must be global var	(cycle 'obj coll '(null found-obj)		'(if (eql (gethash "NAME" obj) name-to-find) (setq found-obj obj))	)	found-obj))(defun prepare NIL (progn	(setq success T)	(setq collgrp (gethash "GROUPS" cillo))	(if (null collgrp) (progn		(setq collgrp (list cillo))		; all-group (cillo also has RECEIVERS and TRANSMITTERS keys)		(setf-gethash "FLAGS" cillo 0)	))	(setq collrcv (gethash "RECEIVERS" cillo))	(setq colltrns (gethash "TRANSMITTERS" cillo))	;	(setq prefs (gethash "PREFERENCES" cillo))	(setq timeline (gethash "TIMELINE" cillo))	(setq duration (- (gethash "STOP" timeline) (gethash "START" timeline)))	; in seconds	(setq sensebuf-size (gethash "SENSEBUFSIZE" prefs))	; limited one	(setq sensebuf-size-h (/ sensebuf-size 2))	(setq sense-rate (gethash "SENSERATE" prefs))	; limited one	(setq audio-rate (gethash "AUDIORATE" prefs))	(setq main-amp (db-to-lin main-gain))	; buffers	(setq buf-counter 0)	(if realtime		(let ((sc-socket (gethash "SUPERCOLLIDEROSC" prefs)))			(datagram-channel-open 'scosc (car sc-socket) (cdr sc-socket))			(datagram-channel-open 'scsync (car sc-socket) (cdr sc-socket))			(osc-bundle-send 'scosc 0.0 (list (list "/dumpOSC" (* dump-osc 3))))			(target-request "SYNC" 0 'scsync)			(setq success (not (null (osc-bundle-send-and-wait 'scsync 0.0 (list (list "/notify" 1)) "/done" 1000))))		)	; else		(progn			(setq stream-files NIL)			(setq stream-bufidx NIL)			(setq stream-fileids NIL);			(setq osc-cmd-file "/Users/rutz/Desktop/test.osc")			(setq osc-cmd-file (temp-file-make))			(file-open 'scosc osc-cmd-file "w")			(setq success T)		)	)	(if (not success) (println "FAILED! supercollider osc notification"))	; create message buffers	(if success		(let ((sense-not-aligned (+ 13 sensebuf-size-h))			  (traj-not-aligned (+ 13 sensebuf-size)));			(setq sense-msgbuf-off (align sense-not-aligned 4));			(byte-buffer-alloc 'sensemsg (+ (+ sense-msgbuf-off 12) (* sensebuf-size-h 4)));			(byte-buffer-write 'sensemsg "/b_setn\\0x00,iii");			(byte-buffer-write 'sensemsg "f" sensebuf-size-h);			(byte-buffer-write 'sensemsg '(0) (+ 9 (- sense-msgbuf-off sense-not-aligned)))	; bufNum, bufOff (initially 0);			(byte-buffer-write 'sensemsg sensebuf-size-h)	; constant # of samples			(setq traj-msgbuf-off (align traj-not-aligned 4))			(byte-buffer-alloc 'trajmsg (+ (+ traj-msgbuf-off 12) (* sensebuf-size 4)))			(byte-buffer-write 'trajmsg "/b_setn\\0x00,iii")			(byte-buffer-write 'trajmsg "f" sensebuf-size)			(byte-buffer-write 'trajmsg '(0) (+ 9 (- traj-msgbuf-off traj-not-aligned)))	; bufNum, bufOff (initially 0)			(byte-buffer-write 'trajmsg sensebuf-size)		; constant # of samples		)	)		; init objects and create mix synths;	(setq collin colltrns);	(setq collout collrcv);	(cycle 'inobj collin 'success;		'(progn;			(setf-gethash "INIT" inobj NIL);			(if (not (eql (gethash "INPROC" inobj) "secondary"));				(setf-gethash "BUSIDX" inobj (if (gethash "AUX" inobj);					(1- (gethash "AUXBUS" inobj));				; else;					(alloc-abus);				));			);		);	)	(setq bundle NIL)	(cycle 'inobj colltrns 'success		'(if (zerop (logand (gethash "FLAGS" inobj) 10))	; is playing?			(let ((bufidx (alloc-buf)))				(request-traj inobj bufidx)				(setf-gethash "BUFIDX" inobj bufidx)				(setq bundle (append bundle (list					(list "/b_alloc" bufidx sensebuf-size 2)				)))			)		)	)	(if (not (or (null bundle) (setq success (my-bundle-send 0.0		(append bundle (list (list "/sync" 8))))))) (println "FAILED! buffer alloc, init"));	(cycle 'outobj collout 'success '(setf-gethash "INIT" outobj NIL));	(cycle 'grp collgrp 'success;		'(if (zerop (logand (gethash "FLAGS" grp) 10))	; is playing?;			(cycle 'inobj (gethash "TRANSMITTERS" grp) 'success;				'(if (zerop (logand (gethash "FLAGS" inobj) 10))	; is playing?;					(progn;						(setq bundle NIL);						(if (null (gethash "INIT" inobj));							(let ((proc (gethash "INPROC" inobj)));								(setf-gethash "INIT" inobj T)			; init once;								(setf-gethash "NODEID" inobj (alloc-node));								(if (eql proc "secondary");									(let ((primary (find-by-name collin (gethash "PRIMARY" inobj))));										(if (null primary);											(println (concatenate 'STRING "ERROR! No primary '" (gethash "PRIMARY" inobj);														"' for secondary '" (gethash "NAME" inobj) "'."));										; else;											(setf-gethash "BUSIDX" inobj (gethash "BUSIDX" main));										);									);								; else;								(if (eql proc "diskin");									(let ((bufidx (alloc-buf)));										(setf-gethash "BUFIDX" inobj bufidx);										(setq bundle (append bundle (list;											(list "/b_alloc" bufidx diskbuf-size);										)));									);								));							);						);						(if (not (or (null bundle) (setq success (my-bundle-send 0.0;							(append bundle (list (list "/sync" 8))))))) (println "FAILED! patcher init"));;					);				);			);		);	)	success))(defun position (time-off) (progn;	(setq frame-off (* audio-rate time-off))	; WARNING : time-off is not accessible within function calls!!	(if (null (my-bundle-send 0.0 (list            (list "/position" time-off)            (list "/sync" 2))))		(progn			(println "TIMEOUT! adjusting position")			NIL		; failure		)	; else		T	; success	)))							(defun play (time-off)	(if (position time-off)        (if (null (my-bundle-send 0.0 (list                        (list "/play")                        (list "/sync" 3))))            (progn                (println "FAILED! play")                NIL		; failure            )        ; else            T	; success        )    ; else        NIL    ))(defun stop (time-off)    (if (null (my-bundle-send 0.0 (list                    (list "/stop")                    (list "/sync" 4))))        (progn            (println "FAILED! stop")            NIL		; failure        )    ; else        T	; success    ))(defun create-gui NIL (progn	(gadget-make NIL "LABEL" '(1 4 2 1) "Main Gain")	(gadget-make main-gain "NUMBER" '(3 4) 0.0 '("dB"))	; -------------------------------- realtime --------------------------------	(if realtime (progn		(gadget-make NIL "LABEL" '(4 4) "  Dump OSC")		(gadget-make dump-osc "CHECKBOX" '(5 4) 0)	; -------------------------------- offline --------------------------------	) (progn ; else		(gadget-make NIL "LABEL" '(1 13 2 1) "Output Sound File")		(gadget-make output-file "PATH" '(3 13 3 1) "" '(NIL "OUTPUT"))		(gadget-make NIL "LABEL" '(1 14 2 1) "Output Format")		(gadget-make output-format "CHOICE" '(3 14) "aiff"			'(("aiff" . "AIFF") ("next" . "NeXT/Sun AU") ("ircam" . "IRCAM")))		(gadget-make output-res "CHOICE" '(4 14 2 1) "int24"			'(("int16" . "16-bit int") ("int24" . "24-bit int") ("int32" . "32-bit int")			  ("float" . "32-bit float") ("double" . "64-bit float")));		(gadget-make NIL "LABEL" '(4 15) "Audio Rate");		(gadget-make output-rate "NUMBER" '(5 15) 44100 '("Hz"))		(gadget-make NIL "LABEL" '(1 15 2 1) "SuperCollider Options")		(gadget-make app-options "TEXT" '(3 15) "")	))	; declare object properties	(let ((inkey "TRANSMITTERS")		  (outkey "RECEIVERS"))			(session-property-add inkey "Process" "INPROC" "STRING" "diskin"			'(("diskin" . "Play Soundfile") ("livein" . "Live Input")			  ("test" . "Test Signal") ("secondary" . "Axis Secondary"))		)		(session-property-add inkey "Audio In Bus" "AUDIOBUS" "INTEGER" 1 '(1 1024 1))		(session-property-add inkey "Audio In File" "AUDIOFILE" "FILE" "")			(session-property-add inkey "Secondary to" "PRIMARY" "STRING" "")		(session-property-add inkey "Gain [dB]" "GAIN" "DOUBLE" 0.0 '(-256.0 256.0 0.01));		(session-property-add outkey "Process" "OUTPROC" "STRING" "matrix";			'(("matrix" . "Volume Matrix") ("delay" . "Delay Insert");			  ("hpf" . "HPF Insert") ("lpf" . "LPF Insert") ("volume" . "Volume Insert"));		);		(session-property-add outkey "Delay [ms]" "DELAY" "DOUBLE" 0.0 '(0.0 1024.0 0.001))		(session-property-add outkey "Audio Out Bus" "AUDIOBUS" "INTEGER" 1 '(1 1024 1))	)	T	; success))