#define EXTENT #0.1##define MAXDIST #0.7071#0dbfs = 1	; soundfile input instrument	; p4 = soundfile path; p5 = za write index	instr 1		asig	diskin	p4, 1, $TIMESTART				zaw		asig, p5	endin	; variable delay	; p4 = za read index; p5 = za write index; p6 = traj path	instr 11		atx aty	diskin	p6, $SENSETOAUDIO, 0, 0, 6	; path, pitch, offset, wrap, format		asig	zar		p4		adist	=		sqrt( ((0.5 - atx) * (0.5 - atx)) + ((0.5 - aty) * (0.5 - aty)) ) * $EXTENT		adly	vdelayx	asig, adist, 2 * $EXTENT, 128	; input, delay [sec], max delay [sec], winsize [smp]				zaw		adly, p5	endin;	instr 11;		ktx kty	readk2	p6, 6, 1	; filename, format, pitch;		asig	zar		p4;		kdist	=		sqrt( ((0.5 - ktx) * (0.5 - ktx)) + ((0.5 - kty) * (0.5 - kty)) ) * $EXTENT;		adist	=		a(kdist);		adly	vdelayx	asig, adist, 2 * $EXTENT, 128	; input, delay [sec], max delay [sec], winsize [smp];				zaw		adly, p5;	endin	; read a transmitter path and write its content to zak variables	; this is necessary because csound has a bug that forbids you to	; use more than one text string in a score i statement.	; p4 = traj path; p5 = za write index for x, p6 = za write index for y	instr 12		atx aty		diskin	p4, $SENSETOAUDIO, 0, 0, 6	; path, pitch, offset, wrap, format					zaw		atx, p5					zaw		aty, p6	endin	; transform two sounds as they are approaching each other	; p4 = traj path1 x za read index; p5 = traj path1 y za read index;	; p6 = traj path1 x za read index; p7 = traj path1 y za read index;	; p8 = trns1 sound za read index; p9 = trns2 sound za read index	; p10 = trns1 za write index; p11 = trns2 za write index	instr 13		atx1		zar		p4		aty1		zar		p5		atx2		zar		p6		aty2		zar		p7		adx			=		atx2 - atx1		ady			=		aty2 - aty1		adist		=		sqrt( (adx * adx) + (ady * ady) )		adistl		limit 	adist, 0, $MAXDIST	; everything beyond MAXDIST not modulated		aweight1	=		adistl / $MAXDIST	; normalized to 0 ... 1		aweight2	=		(1.0 - aweight1) * 24	; XXX test, gain compensation		asig1		zar		p8		asig2		zar		p9		ar1, ai1	hilbert asig1		ar2, ai2	hilbert asig2		ahilb1		=		(ar1 * ar2) - (ai1 * ai2)	; sig1 / sig2 downward modulation		ahilb2		=		(ar1 * ar2) + (ai1 * ai2)	; sig1 / sig2 upward modulation;		atrans1		balance	ahilb1, asig1, 3			; try to adjust to the same energy level;		atrans2		balance	ahilb2, asig2, 3			;	! lpf freq > 3 hz produces clicks !							zaw		(asig1 * aweight1) + (ahilb1 * aweight2), p10					zaw		(asig2 * aweight1) + (ahilb2 * aweight2), p11;					zaw		(asig1 * aweight1), p10;					zaw		(asig2 * aweight1), p11;					zaw		(ahilb1 * aweight2), p10;					zaw		(ahilb2 * aweight2), p11;					printks "dist / weight1 / out ch %d = %.2f / %.2f / %.2f\\n", 4, p8, adist, aweight1, (asig1 * aweight1);					printks "dist / weight1 / out ch %d = %.2f / %.2f / %.2f\\n", 4, p9, adist, aweight1, (asig2 * aweight1)	endin	; mixing stage	; p4 = za read index; p5 = za write index; p6 = sense path	instr 22		asense	diskin	p6, $SENSETOAUDIO, 0, 0, 6	; path, pitch, offset, wrap, format		asig	zar		p4;				printks "mix stage in %d out %d = %.2f * %.2f\\n", 4, p4, p5, asig, asense				zawm	asig * asense, p5	endin	; soundfile output instrument	; p4 = za read index; p5 = output channel; p6 = main gain	instr 77		asig	zarg	p4, p6;		asig	zar		p4				outch	p5, asig;				printks "really out ch %d = %.2f\\n", 4, p5, asig				zacl	p4, p4	endin	; print progress information every 4 seconds	instr 88		iweight		=	1.0 / p3		kschoko		times					printks "CILLO %.2f\\n", 4, kschoko * iweight	endin